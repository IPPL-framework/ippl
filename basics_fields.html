<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IPPL (Independent Parallel Particle Layer): Basics: Fields</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IPPL (Independent Parallel Particle Layer)<span id="projectnumber">&#160;2.0</span>
   </div>
   <div id="projectbrief">IPPL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Basics: Fields </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="field_intro"></a>
Introduction</h1>
<p >This sections provides the readers with a brief background on the used classes for handling Fields in IPPL. </p>
<h2><a class="anchor" id="autotoc_md11"></a>
FieldLayout</h2>
<p >FieldLayout describes how a given index space (represented by an NDIndex object) is distributed among MPI ranks. It performs the initial partitioning. The user may request that a particular dimension not be partitioned by flagging that axis as 'SERIAL' (instead of 'PARALLEL'). </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> pt = 25;</div>
<div class="line"><a class="code hl_class" href="classippl_1_1Index.html">ippl::Index</a> I(pt);</div>
<div class="line"><a class="code hl_class" href="classippl_1_1NDIndex.html">ippl::NDIndex&lt;dim&gt;</a> owned(I, I, I);</div>
<div class="line">std::array&lt;bool, dim&gt; isParallel;</div>
<div class="line">isParallel.fill(<span class="keyword">true</span>);  <span class="comment">// Specifies SERIAL, PARALLEL dims</span></div>
<div class="line"><span class="comment">// all parallel layout, standard domain, normal axis order</span></div>
<div class="line"><a class="code hl_class" href="classippl_1_1FieldLayout.html">ippl::FieldLayout&lt;dim&gt;</a> layout(MPI_COMM_WORLD, owned, isParallel);</div>
<div class="ttc" id="aclassippl_1_1FieldLayout_html"><div class="ttname"><a href="classippl_1_1FieldLayout.html">ippl::FieldLayout</a></div><div class="ttdef"><b>Definition:</b> FieldLayout.h:166</div></div>
<div class="ttc" id="aclassippl_1_1Index_html"><div class="ttname"><a href="classippl_1_1Index.html">ippl::Index</a></div><div class="ttdef"><b>Definition:</b> Index.h:40</div></div>
<div class="ttc" id="aclassippl_1_1NDIndex_html"><div class="ttname"><a href="classippl_1_1NDIndex.html">ippl::NDIndex</a></div><div class="ttdef"><b>Definition:</b> NDIndex.h:21</div></div>
</div><!-- fragment --><p> In this example, we create a 3-dimensional FieldLayout with 25 points in each direction. The layout is distributed among MPI ranks.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
BareField</h2>
<p >The BareField class in IPPL is a template class that represents a numerical field in a computational domain. It is designed to handle data in up to three dimensions and supports various data types through its template parameter T. It provides a Kokkos-based multidimensional array, or view, which is the main data structure used to store field values. The class is integrated with IPPL's field layout and halo cell system for managing computational domains and communication between them, especially in parallel computing environments. A field can be initialized with a specific layout, and it supports operations such as resizing, updating the layout, and operations related to ghost cells which are used for boundary conditions and domain communication. It offers functions for calculating aggregate values over the field, such as sums, maxima, minima, and products. Fields can be assigned values from constants or other fields through expression templates, allowing for complex computations and assignments. The class provides range policies for iteration that can exclude or include ghost layers, giving flexibility in how the field data is traversed and manipulated.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 3;</div>
<div class="line"><span class="keywordtype">int</span> numPoints = 100;</div>
<div class="line"><a class="code hl_class" href="classippl_1_1Index.html">ippl::Index</a> domainIndex(numPoints);</div>
<div class="line"><a class="code hl_class" href="classippl_1_1NDIndex.html">ippl::NDIndex&lt;dim&gt;</a> domain(domainIndex, domainIndex, domainIndex);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classippl_1_1FieldLayout.html">ippl::FieldLayout&lt;dim&gt;</a> layout(domain);</div>
<div class="line">    <span class="comment">// Create a BareField with 3 dimensions, double data type, and 1 ghost layer.</span></div>
<div class="line"><a class="code hl_class" href="classippl_1_1BareField.html">ippl::BareField&lt;double, dim&gt;</a> field(layout, 1);</div>
<div class="ttc" id="aclassippl_1_1BareField_html"><div class="ttname"><a href="classippl_1_1BareField.html">ippl::BareField</a></div><div class="ttdef"><b>Definition:</b> BareField.h:42</div></div>
</div><!-- fragment --><h1><a class="anchor" id="Field"></a>
Field</h1>
<p >The Field class in IPPL is an advanced version of BareField, augmented with a mesh for defining the spatial domain and equipped with customizable boundary conditions. The class is templated to be flexible for various data types (T), dimensions (Dim), mesh types (Mesh), and centering schemes (<a class="el" href="classCentering.html">Centering</a>), along with additional <a class="el" href="namespaceKokkos.html">Kokkos</a> view arguments (ViewArgs...). It's associated with a Mesh object that dictates the structure of the simulation space. Boundary conditions can be set and updated, affecting how the field interacts with the limits of the simulation space. Offers methods for calculating volume integrals and averages, which are useful for analyzing the field over its entire domain. Inherits from BareField, allowing for basic field operations and attribute access.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Example: Creating a Field</h3>
<p >The following example showcases the creation and basic manipulation of a field in IPPL:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceippl.html">ippl</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 3;</div>
<div class="line">std::array&lt;int, dim&gt; points = {256, 256, 256};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classippl_1_1Index.html">ippl::Index</a> Iinput(points[0]);</div>
<div class="line"><a class="code hl_class" href="classippl_1_1Index.html">ippl::Index</a> Jinput(points[1]));</div>
<div class="line"><a class="code hl_class" href="classippl_1_1Index.html">ippl::Index</a> Kinput(points[2]);</div>
<div class="line"><a class="code hl_class" href="classippl_1_1NDIndex.html">ippl::NDIndex&lt;dim&gt;</a> ownedInput(Iinput, Jinput, Kinput);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// specifies SERIAL, PARALLEL dimensions</span></div>
<div class="line">std::array&lt;bool, dim&gt; isParallel;</div>
<div class="line">isParallel.fill(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classippl_1_1FieldLayout.html">ippl::FieldLayout&lt;dim&gt;</a> layoutInput(MPI_COMM_WORLD, ownedInput, isParallel);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> dx = 1.0 / double(points);</div>
<div class="line"><a class="code hl_class" href="classippl_1_1Vector.html">Vector&lt;double,dim&gt;</a> hx = {dx, dx, dx};</div>
<div class="line"><a class="code hl_class" href="classippl_1_1Vector.html">Vector&lt;double,dim&gt;</a> origin = {0.0, 0.0, 0.0};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classippl_1_1UniformCartesian.html">UniformCartesian&lt;double,dim&gt;</a> mesh(owned, hx, origin);</div>
<div class="line"><a class="code hl_class" href="classippl_1_1Field.html">Field&lt;double,dim&gt;</a> field(mesh, layout);</div>
<div class="ttc" id="aclassippl_1_1Field_html"><div class="ttname"><a href="classippl_1_1Field.html">ippl::Field&lt; T, Dim, Mesh_t&lt; Dim &gt;, Centering_t&lt; Dim &gt;, ViewArgs... &gt;</a></div></div>
<div class="ttc" id="aclassippl_1_1UniformCartesian_html"><div class="ttname"><a href="classippl_1_1UniformCartesian.html">ippl::UniformCartesian</a></div><div class="ttdef"><b>Definition:</b> UniformCartesian.h:14</div></div>
<div class="ttc" id="aclassippl_1_1Vector_html"><div class="ttname"><a href="classippl_1_1Vector.html">ippl::Vector</a></div><div class="ttdef"><b>Definition:</b> Vector.h:23</div></div>
<div class="ttc" id="anamespaceippl_html"><div class="ttname"><a href="namespaceippl.html">ippl</a></div><div class="ttdef"><b>Definition:</b> Archive.h:20</div></div>
</div><!-- fragment --><p >This example outlines the steps to define a three-dimensional field, specifying its layout and parallelization strategy.</p>
<h2><a class="anchor" id="useful_field_functions"></a>
Useful Field Functions</h2>
<h3><a class="anchor" id="useful_field_ops"></a>
Mathematical Operations</h3>
<div class="fragment"><div class="line"><span class="comment">// Computes Lp norm of the field. For Max. norm p=0. Default is 2-norm.</span></div>
<div class="line"><span class="keyword">auto</span> fieldNorm = norm(field,p);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Computes dot product of vector fields (in each element) and returns a scalar field</span></div>
<div class="line"><span class="keyword">auto</span> field = dot(vfield, vfield)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Innerproduct of two scalar fields and returns a scalar </span></div>
<div class="line"><span class="keyword">auto</span> fSquare = innerProduct(field, field);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Computes the sum of the field</span></div>
<div class="line"><span class="keyword">auto</span> fieldSum = field.sum();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// $\int f dV$ computed using midpoint rule</span></div>
<div class="line"><span class="keyword">auto</span> fieldVolIntegral = field.getVolumeIntegral();</div>
</div><!-- fragment --><h3><a class="anchor" id="field_properties"></a>
Field Properties</h3>
<div class="fragment"><div class="line"><span class="comment">// Returns the range policy for the fields excluding the ghosts layers.</span></div>
<div class="line"><span class="comment">// If you want to include ghost layers specify nghost as an argument</span></div>
<div class="line"><span class="keyword">auto</span> fieldRange = field.getFieldRangePolicy(); </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Return the number of ghost layers in the field</span></div>
<div class="line"><span class="keyword">auto</span> nghost = field.getNghost();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns the underyling field layout</span></div>
<div class="line"><span class="keyword">auto</span> layout = field.getLayout();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the local n-dimension indices from the field layout</span></div>
<div class="line"><span class="keyword">auto</span> lDom = layout.getLocalNDIndex();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the global domain indices from the field layout</span></div>
<div class="line"><span class="keyword">auto</span> gDom = layout.getDomain();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Shallow copy of fields. Changing field2 changes field1 also.</span></div>
<div class="line"><span class="keyword">auto</span> field2 = field1;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Deep copy of fields. Changing field2 does not change field1.</span></div>
<div class="line"><span class="keyword">auto</span> field2 = field1.deepCopy();</div>
</div><!-- fragment --><h3><a class="anchor" id="field_distributed"></a>
Parallel Helper Functions</h3>
<div class="fragment"><div class="line"><span class="comment">// Return the underyling Kokkos View of the field</span></div>
<div class="line"><span class="keyword">auto</span> fview = field.getView();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Return the Host Mirror corresponding to the Kokkos device view </span></div>
<div class="line"><span class="comment">// of the field. It is a no-op if the field is already on the host.</span></div>
<div class="line"><span class="keyword">auto</span> fHostView = field.getHostMirror();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// You still have to do a deep copy to get the data from the device to host or vice-versa</span></div>
<div class="line">Kokkos::deep_copy(fHostView, fview); <span class="comment">// device to host</span></div>
<div class="line">Kokkos::deep_copy(fview, fHostView); <span class="comment">// host to device</span></div>
</div><!-- fragment --><h3><a class="anchor" id="init_field_from_func"></a>
Initializing a Field from a Function</h3>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classippl_1_1NDIndex.html">ippl::NDIndex&lt;Dim&gt;</a>&amp; lDom = fieldLayout.getLocalNDIndex();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> nghost = field.getNghost();</div>
<div class="line"><span class="keyword">auto</span> fview = field.getView();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>index_array_type = typenamep <a class="code hl_class" href="classippl_1_1Vector.html">ippl::RangePolicy&lt;Dim&gt;::index_array_type</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespaceippl.html#ab5d78bcf87f750df8cdb9546221d0f71">ippl::parallel_for</a>( </div>
<div class="line">    <span class="stringliteral">&quot;Assign a field based on func&quot;</span>, field.getFieldRangePolicy(),</div>
<div class="line">    KOKKOS_LAMBDA(<span class="keyword">const</span> index_array_type&amp; args) {</div>
<div class="line">        <span class="comment">// local to global index conversion</span></div>
<div class="line">        <a class="code hl_class" href="classippl_1_1Vector.html">Vector&lt;double, Dim&gt;</a> xvec = (args + lDom.<a class="code hl_function" href="classippl_1_1NDIndex.html#a867c03b8f54e8241f83860b4d058c7a5">first</a>() - nghost + 0.5) * hr + origin;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// ippl::apply accesses the view at the given indices and obtains a </span></div>
<div class="line">        <span class="comment">// reference; see src/Expression/IpplOperations.h</span></div>
<div class="line">        <a class="code hl_function" href="namespaceippl.html#a262c6fa860230c30f0a336de14009bd0">ippl::apply</a>(fview, args) = func(xvec);</div>
<div class="line">    });</div>
<div class="ttc" id="aclassippl_1_1NDIndex_html_a867c03b8f54e8241f83860b4d058c7a5"><div class="ttname"><a href="classippl_1_1NDIndex.html#a867c03b8f54e8241f83860b4d058c7a5">ippl::NDIndex::first</a></div><div class="ttdeci">KOKKOS_INLINE_FUNCTION Vector&lt; int, Dim &gt; first() const</div><div class="ttdef"><b>Definition:</b> NDIndex.hpp:163</div></div>
<div class="ttc" id="anamespaceippl_html_a262c6fa860230c30f0a336de14009bd0"><div class="ttname"><a href="namespaceippl.html#a262c6fa860230c30f0a336de14009bd0">ippl::apply</a></div><div class="ttdeci">KOKKOS_INLINE_FUNCTION constexpr decltype(auto) apply(const View &amp;view, const Coords &amp;coords)</div><div class="ttdef"><b>Definition:</b> IpplOperations.h:64</div></div>
<div class="ttc" id="anamespaceippl_html_ab5d78bcf87f750df8cdb9546221d0f71"><div class="ttname"><a href="namespaceippl.html#ab5d78bcf87f750df8cdb9546221d0f71">ippl::parallel_for</a></div><div class="ttdeci">void parallel_for(const std::string &amp;name, const ExecPolicy &amp;policy, const FunctorType &amp;functor)</div><div class="ttdef"><b>Definition:</b> ParallelDispatch.h:215</div></div>
</div><!-- fragment --><ul>
<li>To write dimension independent kernels use the wrappers '<a class="el" href="namespaceippl.html#ab5d78bcf87f750df8cdb9546221d0f71">ippl::parallel_for</a>' and '<a class="el" href="namespaceippl.html#ab8faeca32cc3523c0e39f7c0e6ec7cbc">ippl::parallel_reduce</a>'.</li>
<li>If you don't want dimension independence in your application then you can just use 'Kokkos::parallel_for' and 'Kokkos::parallel_reduce'. </li>
</ul>
<h3><a class="anchor" id="boundary_conditions_fields"></a>
Boundary Conditions for Fields</h3>
<p >Setting BCs for fields is a necessary prerequisite before applying differential operators on fields! Otherwise you will get garbage for the points close to the boundary. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classippl_1_1BConds.html">ippl::BConds&lt;Field&lt;t, Dim&gt;</a>, <a class="code hl_variable" href="BumponTailInstability_8cpp.html#afef54e0ebfe65da0a396b342dcbe30f5">Dim</a>&gt; bc_type;</div>
<div class="line">bc_type bc;</div>
<div class="line"><span class="comment">// Available BCs in Ippl see src/Field/BcTypes.h</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0; i &lt; 2*<a class="code hl_variable" href="BumponTailInstability_8cpp.html#afef54e0ebfe65da0a396b342dcbe30f5">Dim</a>; ++i){</div>
<div class="line">    bc[i]= std::make_shared&lt;ippl::PeriodicFace&lt;Field&lt;T, Dim&gt;&gt;&gt;(i);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">field.setFieldBC(bc);</div>
<div class="line">bc_type BCs = field.getFieldBC();</div>
<div class="ttc" id="aBumponTailInstability_8cpp_html_afef54e0ebfe65da0a396b342dcbe30f5"><div class="ttname"><a href="BumponTailInstability_8cpp.html#afef54e0ebfe65da0a396b342dcbe30f5">Dim</a></div><div class="ttdeci">constexpr unsigned Dim</div><div class="ttdef"><b>Definition:</b> BumponTailInstability.cpp:22</div></div>
<div class="ttc" id="aclassippl_1_1BConds_html"><div class="ttname"><a href="classippl_1_1BConds.html">ippl::BConds</a></div><div class="ttdef"><b>Definition:</b> BConds.h:23</div></div>
</div><!-- fragment --> <h3><a class="anchor" id="diff_op_fields"></a>
Differential Operators for Fields</h3>
<div class="fragment"><div class="line"><span class="keyword">using </span>mesh_type = <a class="code hl_class" href="classippl_1_1UniformCartesian.html">ippl::UniformCartesian&lt;T, Dim &gt;</a>;</div>
<div class="line"><span class="keyword">using </span>centering_type = <span class="keyword">typename</span> mesh_type::DefaultCentering ;</div>
<div class="line"><span class="keyword">using </span>sfield_type = <a class="code hl_class" href="classippl_1_1Field.html">Field&lt;double, Dim, mesh_type, centering_type&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>vfield_type = <a class="code hl_class" href="classippl_1_1Field.html">Field&lt;Vector&lt;double, Dim&gt;</a>, <a class="code hl_variable" href="BumponTailInstability_8cpp.html#afef54e0ebfe65da0a396b342dcbe30f5">Dim</a>, mesh_type, centering_type&gt;;</div>
<div class="line"><span class="keyword">using </span>mfield_type = Field &lt;Vector&lt;Vector&lt;double, Dim&gt;, <a class="code hl_variable" href="BumponTailInstability_8cpp.html#afef54e0ebfe65da0a396b342dcbe30f5">Dim</a>&gt;, <a class="code hl_variable" href="BumponTailInstability_8cpp.html#afef54e0ebfe65da0a396b342dcbe30f5">Dim</a>, mesh_type, centering_type&gt;;</div>
<div class="line"> </div>
<div class="line">sfield_type sfield (field.get_mesh(), field.getLayout());</div>
<div class="line">vfield_type vfield (field.get_mesh (), field.getLayout ());</div>
<div class="line">mfield_type mfield (field.get_mesh (), field.getLayout ());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Computes gradient of a scalar field by cell - centered finite difference and returns a vector field</span></div>
<div class="line">vfield = grad(field);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Computes divergence of a vector field by cell - centered finite difference and returns a scalar field</span></div>
<div class="line">field = div(vfield);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Computes curl of a scalar field by cell - centered finite difference and returns a vector field</span></div>
<div class="line"><span class="comment">// Only available in 3 D for the moment</span></div>
<div class="line">vfield = curl(field);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Computes Hessian of a scalar field by cell - centered finite difference and returns a matrix field</span></div>
<div class="line"><span class="comment">// There is no native matrix data type in ippl so the output field is vector of vectors</span></div>
<div class="line">mfield = hess(field);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Computes Laplacian of a scalar field by cell - centered finite difference and returns a scalar field .</span></div>
<div class="line"><span class="comment">// At the moment ippl does not do a copy of the original field when you specify the same scalar field</span></div>
<div class="line"><span class="comment">// in both rhs and lhs . So the user has to allocate a different scalar field for lhs and rhs .</span></div>
<div class="line">sfield = laplace(field);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
