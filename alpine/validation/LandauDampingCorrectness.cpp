// LandauDamping Correctness Validation Test
//
// This test compares the CSV output generated by the LandauDamping simulation
// with a reference (valid) result file. All numerical values must be within
// a tolerance of 1E-7 for the test to pass.
//
// Usage:
//   ./LandauDampingCorrectness [output_csv] [reference_csv] [tolerance]
//
// Where:
//   output_csv    : Path to the generated FieldLandau_*.csv file
//                   (default: data/FieldLandau_*_manager.csv - finds first match)
//   reference_csv : Path to the reference file
//                   (default: ../../alpine/validation/FieldLandau_valid_result.csv)
//   tolerance     : Absolute tolerance for comparison (default: 1e-7)

#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

namespace fs = std::filesystem;

// Structure to hold a row of CSV data
struct CSVRow {
    double time;
    double Ex_field_energy;
    double Ex_max_norm;

    CSVRow()
        : time(0.0)
        , Ex_field_energy(0.0)
        , Ex_max_norm(0.0) {}

    CSVRow(double t, double e, double n)
        : time(t)
        , Ex_field_energy(e)
        , Ex_max_norm(n) {}
};

// Trim whitespace from string
std::string trim(const std::string& str) {
    size_t first = str.find_first_not_of(" \t\r\n");
    if (first == std::string::npos)
        return "";
    size_t last = str.find_last_not_of(" \t\r\n");
    return str.substr(first, (last - first + 1));
}

// Find first CSV file matching pattern in directory
std::string findCSVFile(const std::string& pattern) {
    // If pattern is a file that exists, return it
    if (fs::exists(pattern) && fs::is_regular_file(pattern)) {
        return pattern;
    }

    // Try to find a matching file in data/ directory
    std::string dataDir = "data";
    if (fs::exists(dataDir) && fs::is_directory(dataDir)) {
        for (const auto& entry : fs::directory_iterator(dataDir)) {
            if (entry.is_regular_file() && entry.path().extension() == ".csv") {
                std::string filename = entry.path().filename().string();
                if (filename.find("FieldLandau_") == 0
                    && filename.find("_manager.csv") != std::string::npos) {
                    return entry.path().string();
                }
            }
        }
    }

    return pattern;  // Return original pattern if not found
}

// Load CSV file into vector of CSVRow
bool loadCSV(const std::string& filepath, std::vector<CSVRow>& data, bool& hasMaxNorm,
             std::string& errorMsg) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        errorMsg = "Could not open file: " + filepath;
        return false;
    }

    std::string line;
    bool isFirstLine = true;
    int lineNum      = 0;
    hasMaxNorm       = false;

    while (std::getline(file, line)) {
        lineNum++;
        line = trim(line);

        // Skip empty lines
        if (line.empty())
            continue;

        // Check header line
        if (isFirstLine) {
            isFirstLine = false;
            // Check if we have Ex_max_norm column
            hasMaxNorm = (line.find("Ex_max_norm") != std::string::npos);
            continue;
        }

        // Parse data line
        std::istringstream iss(line);
        double time, energy, maxNorm = 0.0;

        if (!(iss >> time >> energy)) {
            errorMsg = "Failed to parse line " + std::to_string(lineNum) + ": " + line;
            return false;
        }

        // Try to read third column if present
        if (hasMaxNorm) {
            if (!(iss >> maxNorm)) {
                // If header says we have max_norm but can't read it, it's an error
                errorMsg = "Expected Ex_max_norm column but failed to parse at line "
                           + std::to_string(lineNum);
                return false;
            }
        }

        data.emplace_back(time, energy, maxNorm);
    }

    file.close();

    if (data.empty()) {
        errorMsg = "No data rows found in file: " + filepath;
        return false;
    }

    return true;
}

// Compare two CSV datasets
bool compareCSVData(const std::vector<CSVRow>& output, const std::vector<CSVRow>& reference,
                    bool outputHasMaxNorm, bool refHasMaxNorm, double tolerance,
                    std::vector<std::string>& errors) {
    // Check row count
    if (output.size() != reference.size()) {
        std::ostringstream oss;
        oss << "Row count mismatch: output has " << output.size() << " rows, reference has "
            << reference.size() << " rows";
        errors.push_back(oss.str());
        return false;
    }

    // Compare each row
    std::vector<int> timeErrors, energyErrors, normErrors;
    double maxTimeDiff = 0.0, maxEnergyDiff = 0.0, maxNormDiff = 0.0;

    for (size_t i = 0; i < output.size(); ++i) {
        // Compare time
        double timeDiff = std::abs(output[i].time - reference[i].time);
        if (timeDiff > tolerance) {
            timeErrors.push_back(static_cast<int>(i));
            maxTimeDiff = std::max(maxTimeDiff, timeDiff);
        }

        // Compare Ex_field_energy
        double energyDiff = std::abs(output[i].Ex_field_energy - reference[i].Ex_field_energy);
        if (energyDiff > tolerance) {
            energyErrors.push_back(static_cast<int>(i));
            maxEnergyDiff = std::max(maxEnergyDiff, energyDiff);
        }

        // Compare Ex_max_norm if both have it
        if (outputHasMaxNorm && refHasMaxNorm) {
            double normDiff = std::abs(output[i].Ex_max_norm - reference[i].Ex_max_norm);
            if (normDiff > tolerance) {
                normErrors.push_back(static_cast<int>(i));
                maxNormDiff = std::max(maxNormDiff, normDiff);
            }
        }
    }

    // Report errors
    bool hasErrors = false;

    if (!timeErrors.empty()) {
        hasErrors = true;
        std::ostringstream oss;
        oss << "Column 'time': " << timeErrors.size() << " value(s) outside tolerance "
            << "(tolerance=" << std::scientific << tolerance << ", max_diff=" << maxTimeDiff
            << ") at rows [";
        for (size_t i = 0; i < std::min(timeErrors.size(), size_t(10)); ++i) {
            if (i > 0)
                oss << ", ";
            oss << timeErrors[i];
        }
        if (timeErrors.size() > 10)
            oss << ", ...";
        oss << "]";
        errors.push_back(oss.str());
    }

    if (!energyErrors.empty()) {
        hasErrors = true;
        std::ostringstream oss;
        oss << "Column 'Ex_field_energy': " << energyErrors.size() << " value(s) outside tolerance "
            << "(tolerance=" << std::scientific << tolerance << ", max_diff=" << maxEnergyDiff
            << ") at rows [";
        for (size_t i = 0; i < std::min(energyErrors.size(), size_t(10)); ++i) {
            if (i > 0)
                oss << ", ";
            oss << energyErrors[i];
        }
        if (energyErrors.size() > 10)
            oss << ", ...";
        oss << "]";
        errors.push_back(oss.str());
    }

    if (!normErrors.empty()) {
        hasErrors = true;
        std::ostringstream oss;
        oss << "Column 'Ex_max_norm': " << normErrors.size() << " value(s) outside tolerance "
            << "(tolerance=" << std::scientific << tolerance << ", max_diff=" << maxNormDiff
            << ") at rows [";
        for (size_t i = 0; i < std::min(normErrors.size(), size_t(10)); ++i) {
            if (i > 0)
                oss << ", ";
            oss << normErrors[i];
        }
        if (normErrors.size() > 10)
            oss << ", ...";
        oss << "]";
        errors.push_back(oss.str());
    }

    return !hasErrors;
}

int main(int argc, char* argv[]) {
    // Default values
    std::string outputCSV    = "data/FieldLandau_*_manager.csv";
    std::string referenceCSV = "../../alpine/validation/FieldLandau_valid_result.csv";
    double tolerance         = 1e-7;

    // Parse command line arguments
    if (argc > 1) {
        if (std::string(argv[1]) == "--help" || std::string(argv[1]) == "-h") {
            std::cout << "LandauDamping Correctness Validation Test\n\n"
                      << "Usage: " << argv[0] << " [output_csv] [reference_csv] [tolerance]\n\n"
                      << "Arguments:\n"
                      << "  output_csv    : Path to generated CSV file (default: "
                         "data/FieldLandau_*_manager.csv)\n"
                      << "  reference_csv : Path to reference CSV file (default: "
                         "../../alpine/validation/FieldLandau_valid_result.csv)\n"
                      << "  tolerance     : Absolute tolerance for comparison (default: 1e-7)\n\n"
                      << "Exit codes:\n"
                      << "  0 : PASS - Output matches reference within tolerance\n"
                      << "  1 : FAIL - Output does not match reference\n"
                      << "  2 : ERROR - File I/O or parsing error\n\n"
                      << "Examples:\n"
                      << "  " << argv[0] << "\n"
                      << "  " << argv[0] << " data/FieldLandau_2_manager.csv\n"
                      << "  " << argv[0] << " output.csv reference.csv 1e-6\n";
            return 0;
        }
        outputCSV = argv[1];
    }
    if (argc > 2) {
        referenceCSV = argv[2];
    }
    if (argc > 3) {
        tolerance = std::atof(argv[3]);
    }

    // Find output file if pattern given
    outputCSV = findCSVFile(outputCSV);

    std::cout << "LandauDamping Correctness Validation\n";
    std::cout << "=====================================\n";
    std::cout << "Output file:    " << outputCSV << "\n";
    std::cout << "Reference file: " << referenceCSV << "\n";
    std::cout << "Tolerance:      " << std::scientific << tolerance << "\n";
    std::cout << std::endl;

    // Load output CSV
    std::vector<CSVRow> outputData;
    bool outputHasMaxNorm = false;
    std::string errorMsg;

    if (!loadCSV(outputCSV, outputData, outputHasMaxNorm, errorMsg)) {
        std::cerr << "✗ ERROR: Failed to load output CSV\n";
        std::cerr << "  " << errorMsg << std::endl;
        return 2;
    }

    std::cout << "Loaded output: " << outputData.size() << " rows";
    if (outputHasMaxNorm)
        std::cout << " (with Ex_max_norm column)";
    std::cout << std::endl;

    // Load reference CSV
    std::vector<CSVRow> referenceData;
    bool refHasMaxNorm = false;

    if (!loadCSV(referenceCSV, referenceData, refHasMaxNorm, errorMsg)) {
        std::cerr << "✗ ERROR: Failed to load reference CSV\n";
        std::cerr << "  " << errorMsg << std::endl;
        return 2;
    }

    std::cout << "Loaded reference: " << referenceData.size() << " rows";
    if (refHasMaxNorm)
        std::cout << " (with Ex_max_norm column)";
    std::cout << std::endl;
    std::cout << std::endl;

    // Compare data
    std::vector<std::string> errors;
    bool passed = compareCSVData(outputData, referenceData, outputHasMaxNorm, refHasMaxNorm,
                                 tolerance, errors);

    if (passed) {
        std::cout << "✓ PASS: Output matches reference within tolerance" << std::endl;
        return 0;
    } else {
        std::cout << "✗ FAIL: Output does not match reference" << std::endl;
        for (const auto& error : errors) {
            std::cout << "  - " << error << std::endl;
        }
        return 1;
    }
}
